---
title: "Jannink and Wu 2003 MCMC methods"
author: "Frederick J. Boehm"
date: "1/19/2020"
output: html_document
params:
  lastmod: !r lubridate::now()
bibliography: references.bib
---

Last modified: `r params$lastmod`.

IN the terminology of @jannink2003estimating, the sequence of updates per iteration is:

1. update QTL inheritance matrix $Q$  
1. update QTL allelic effects $a$  
1. update family means $\beta$ and residual variance $\sigma^2$  
1. update configuration given number of alleles, ie, $C | l$  
1. update the number of alleles $l$

The later @jannink2004optimal uses similar sequence of updates:

1. Update the number of QTL alleles 
1. Update the configuration given the number of alleles
1. update QTL variance (when there are multiple QTL)
1. update allelic effects
1. update position and genotypes jointly
1. update family means



```{r}
get_output <- function(numerator, denominator, current, proposal){
  alpha <- min(1, prod(numerator / denominator))
  bernoulli <- rbinom(n = 1, size = 1, prob = alpha)
  if (bernoulli) {out <- proposal} else {out <- current}
  return(list(out = out, bernoulli = bernoulli, alpha = alpha, numerator = numerator, denominator = denominator, proposal = proposal))
}

enumerate_configuration <- function(configuration){
  return(apply(X = configuration, MARGIN = 1, FUN = function(x)which(x == 1)))
}
#' Use configuration and effects vector to get each founder's effect, even when there are fewer alleles than founders
expand_effects <- function(effects, enumerated_configuration){
  return(effects[enumerated_configuration])
}

# update one effect from the vector of effects
update_effect <- function(effects, 
                          effect_index, # which element of effects is considered for update
                           distance = 0.3, 
                           trait, 
                           residual_variance, 
                           collapsed_genotypes){
  proposal <- effects
  proposal[effect_index] <- runif(n = 1, 
                    min = effects[effect_index] - distance, 
                    max = effects[effect_index] + distance
                    )
  numerator <- dnorm(trait, 
                     mean = collapsed_genotypes %*% proposal, 
                     sd = sqrt(residual_variance)
                     ) * 
    dnorm(proposal[effect_index], 
          mean = 0, 
          sd = sqrt(var(trait))
          )
  denominator <- dnorm(trait, 
                     mean = collapsed_genotypes %*% effects, 
                     sd = sqrt(residual_variance)
                     ) * 
    dnorm(effects[effect_index], 
          mean = 0, 
          sd = sqrt(var(trait))
          )
  output <- get_output(numerator = numerator, 
                       denominator = denominator, 
                       current = effects, 
                       proposal = proposal
                       )
  return(output)
}

update_residual_variance <- function(residual_variance, 
                                     distance = 2, 
                                     trait, 
                                     collapsed_genotypes, 
                                     effects){
  proposal <- runif(n = 1, 
                    min = max(0, residual_variance - distance), 
                    max = residual_variance + distance
                    )
  numerator <- dnorm(trait, 
                     mean = collapsed_genotypes %*% effects, 
                     sd = sqrt(proposal)
                     ) * (1 / min(2 * distance, distance + proposal))
  denominator <- dnorm(trait, 
                       mean = collapsed_genotypes %*% effects, 
                       sd = sqrt(residual_variance)
                       ) * (1 / min(2 * distance, distance + residual_variance))
  output <- get_output(numerator = numerator, 
                       denominator = denominator, 
                       current = residual_variance, 
                       proposal = proposal
                       )
  return(output)
}
```


```{r}
#' Update allelic number (and, of course, configuration, too.)
#' @param configuration an allelic series matrix, ie, binary matrix of 0s and 1s mapping founders to alleles at a single QTL
#' @param genoprobs genotype probabilities matrix for a single marker, ie, n_subjects by n_founders at 1 marker

update_allelic_number <- function(configuration, 
                                  genoprobs, 
                                  effects, 
                                  trait, 
                                  residual_variance){
  allelic_number <- ncol(configuration)
  founder_number <- nrow(configuration)
  # get proposal
  if ((allelic_number < founder_number) & (allelic_number > 2)){
    increase_indicator <- as.logical(rbinom(n = 1, 
                                 size = 1, 
                                 prob = 0.5
                                 )
    )
  }
  if (allelic_number == 2){
    increase_indicator <- TRUE
  }
  if (allelic_number == founder_number){
    increase_indicator <- FALSE
  }
  if (increase_indicator){
    cp_out <- calc_prob_allelic_number_increase(configuration,
                                                genoprobs, 
                                                effects, 
                                                trait, 
                                                residual_variance
                                                )
  } else { # propose a decrease in allelic number
    cp_out <- calc_prob_allelic_number_decrease(configuration, 
                                                genoprobs, 
                                                effects, 
                                                trait, 
                                                residual_variance
                                                )
  }
  output <- get_output(numerator = cp_out$numerator, 
             denominator = cp_out$denominator, 
             current = list(effects, configuration), 
             proposal = list(cp_out$effects_proposal, cp_out$configuration_proposal)
             )
  return(output)
} ## need to define inputs, collapsed_geno, collapsed_geno_proposal, etc.##
##
calc_prob_allelic_number_decrease <- function(configuration, 
                                              genoprobs, 
                                              effects, 
                                              trait, 
                                              residual_variance){
# propose a decrease in allelic number
  allelic_number <- ncol(configuration)
  founder_number <- nrow(configuration)
    # choose two alleles to combine into one
  alleles_to_combine <- sample(1:allelic_number, size = 2, replace = FALSE) # vector of length 2
  # make configuration proposal matrix
  configuration_proposal <- calc_configuration_combining_alleles(configuration, alleles_to_combine)
  verify(configuration_proposal)
  # make effects proposal vector
  effects_proposal <- effects[ - max(alleles_to_combine)]
  # define collapsed genotypes
  collapsed_genotypes_proposal <- genoprobs %*% configuration_proposal
  collapsed_genotypes <- genoprobs %*% configuration
  numerator <- allelic_number * 
    (allelic_number - 1) * 
    count_configurations(founder_number = founder_number, 
                         allelic_number = allelic_number
                         ) * 
    dnorm(trait, 
          mean = collapsed_genotypes_proposal %*% effects_proposal, 
          sd = sqrt(residual_variance)
          )
  # define etau plus etav
  eta_u_plus_v <- colSums(configuration_proposal)[min(alleles_to_combine)]
  l2_proposal <- sum(colSums(configuration_proposal) > 1)
  denominator <- 2 * (2 ^ (eta_u_plus_v - 1) - 1) * 
    l2_proposal * 
    count_configurations(founder_number = founder_number, 
                         allelic_number = allelic_number - 1
                         ) * 
    dnorm(trait, 
          mean = collapsed_genotypes %*% effects, 
          sd = sqrt(residual_variance)
          )
  return(list(numerator = numerator, 
              denominator = denominator,
              configuration_proposal = configuration_proposal, 
              effects_proposal = effects_proposal
              )
         )
}
##
calc_configuration_combining_alleles <- function(configuration, 
                                                 alleles_to_combine){
  configuration[ , min(alleles_to_combine)] <- configuration[ , min(alleles_to_combine)] +
    configuration[ , max(alleles_to_combine)]
  out <- configuration[, - max(alleles_to_combine)]
  verify_configuration(out)
  return(out)
}
##
calc_prob_allelic_number_increase <- function(configuration,
                                              genoprobs, 
                                              effects, 
                                              trait, 
                                              residual_variance){
    # choose an allele shared by at least two founders
    ## calculate column sums of configuration matrix
    colsums <- colSums(configuration)
    shared_alleles <- which(colsums > 1)
    allele_to_split <- sample(x = shared_alleles, size = 1)
    founders_to_split <- which(configuration[ , allele_to_split] == 1)
    group_indicators <- rbinom(n = length(founders_to_split), size = 1, prob = 0.5)
    # make new configuration matrix
    configuration_proposal <- configuration
    founder_number <- nrow(configuration)
    allelic_number <- ncol(configuration)
    binary <- rep(0, founder_number)
    binary[founders_to_split[as.logical(group_indicators)]] <- 1
    configuration_proposal[ , allele_to_split] <- binary
    ## add a new column
    binary0 <- rep(0, founder_number)
    binary0[founders_to_split[as.logical(1 - group_indicators)]] <- 1
    configuration_proposal <- cbind(configuration_proposal, binary0)
    colnames(configuration_proposal) <- NULL
    verify_configuration(configuration_proposal)
    #draw new effect for proposal
    new_effect <- rnorm(n = 1, 
                        mean = 0, 
                        sd = sqrt(var(trait))
                        ) # check this!!
    effects_proposal <- c(effects, new_effect)
    eta_u <- colSums(configuration)[allele_to_split] 
    # how many founders have the allele to 'split'??
    # collapse genoprobs in each of two ways
    collapsed_genotypes <- genoprobs %*% configuration
    collapsed_genotypes_proposal <- genoprobs %*% configuration_proposal
    
    numerator <- 2 * (2 ^ (eta_u - 1) - 1) * 
      sum(colSums(configuration) > 1) * 
      count_configurations(founder_number = founder_number, 
                           allelic_number = allelic_number
                           ) * 
      dnorm(trait, 
            mean = collapsed_genotypes_proposal %*% effects_proposal, 
            sd = sqrt(residual_variance)
            )
    # how many alleles are carried by at least 2 founders?
    denominator <- (allelic_number + 1) * 
      allelic_number * 
      count_configurations(founder_number = founder_number, 
                           allelic_number = 1 + allelic_number
                           ) * 
      dnorm(trait, 
            mean = collapsed_genotypes %*% effects, 
            sd = sqrt(residual_variance)
            )
  return(list(numerator = numerator, 
              denominator = denominator,
              configuration_proposal = configuration_proposal, 
              effects_proposal = effects_proposal
              )
         )
}


count_configurations <- function(founder_number = 8, allelic_number){
  # allele labels don't matter, but founder labels matter.
  # we need stirling numbers of the second kind
  return(as.integer(gmp::Stirling2(n = founder_number, k = allelic_number)))
}
```

```{r}
# update configuration for a fixed number of alleles
update_configuration <- function(configuration, 
                                 trait, 
                                 genoprobs, 
                                 effects, 
                                 residual_variance){
  # determine which alleles have multiple founders
  alleles_with_multiple_founders <- which(colSums(configuration) > 1)
  # randomly choose an allele with multiple founders
  allele_to_change <- sample(alleles_with_multiple_founders, size = 1)
  # choose a founder with 'allele_to_change' 
  founders_with_allele_to_change <- which(configuration[, allele_to_change] == 1)
  # randomly choose one from 'founders_with_allele_to_change'
  founder_to_change <- sample(founders_with_allele_to_change, size = 1)
  v_possible_alleles <- (1:ncol(configuration))[- allele_to_change]
  v_allele <- sample(v_possible_alleles, size = 1)
  configuration_proposal <- configuration
  configuration_proposal[founder_to_change, allele_to_change] <- 0 
  configuration_proposal[founder_to_change, v_allele] <- 1
  verify_configuration(configuration_proposal)
  eta_u <- colSums(configuration)[allele_to_change]
  eta_v <- colSums(configuration_proposal)[v_allele]
  l2 <- sum(colSums(configuration) > 1)
  l2_proposal <- sum(colSums(configuration_proposal) > 1)
  collapsed_genotypes <- genoprobs %*% configuration
  collapsed_genotypes_proposal <- genoprobs %*% configuration_proposal
  numerator <- eta_u * l2 * dnorm(trait, 
                                  mean = collapsed_genotypes_proposal %*% effects, 
                                  sd = sqrt(residual_variance)
                                  )
  denominator <- eta_v * l2_proposal * dnorm(trait, 
                                             mean = collapsed_genotypes %*% effects, 
                                             sd = sqrt(residual_variance)
                                             )
  output <- get_output(numerator = numerator, 
                       denominator = denominator, 
                       current = configuration, 
                       proposal = configuration_proposal
                       )
  return(output)
}
```

```{r}
outs <- list()
current <- list(configuration = config, 
                effects = c(1, 3), 
                residual_variance = 2
                )

for (i in 1:1000){
  if (i > 1) current <- output[[i - 1]]
  # update allelic number
  out <- update_allelic_number(configuration = current$configuration, 
                               genoprobs = geno$`1`[ , , 100], 
                               effects = current$effects, 
                               trait = tr, 
                               residual_variance = current$residual_variance
                               )
  current$effects <- out$out[[1]] 
  current$configuration <- out$out[[2]]
  # update configuration for fixed allelic number
  current$configuration <- update_configuration(configuration = current$configuration, 
                                        trait = tr, 
                                        genoprobs = geno$`1`[ , , 100], 
                                        effects = current$effects, 
                                        residual_variance = current$residual_variance
                                        )$out
  # iterate over effects vector
  for (k in seq_along(effects)){
    current$effects <- update_effect(effects = current$effects, 
                              effect_index = k,
                              trait = tr, 
                              residual_variance = current$residual_variance,
                              collapsed_genotypes = geno$`1`[ , , 100] %*% current$configuration
                              )$out
  }
  ##
  current$residual_variance <- update_residual_variance(residual_variance = current$residual_variance, 
                                                trait = tr,
                                                collapsed_genotypes = geno$`1`[ , , 100] %*% current$configuration, 
                                                effects = current$effects
                                                )$out
  outs[[i]] <- current 
}
```


## Simulate traits

```{r load_attie}
  geno <- readRDS("../data/derived_data/attie_geno.rds")
```

```{r}
config <- matrix(nrow = 8, ncol = 2)
config[, 1] <- rep(c(0, 1), each = 4)
config[, 2] <- 1 - config[, 1]
tr <- reducedscan::sim1(aprobs = geno$`1`[ , , 100], allelic_series = config, allelic_effects = c(1, 3))
```



## Apply mcmc to infer allelic series at QTL



```{r, check_configuration}
verify_configuration <- function(configuration){
  stopifnot(sum(configuration) == nrow(configuration))
  stopifnot(rowSums(configuration) == rep(1, nrow(configuration)))
  stopifnot(sum(configuration == 0) == (ncol(configuration) - 1) * nrow(configuration))
}
```
