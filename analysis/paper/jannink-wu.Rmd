---
title: "Jannink and Wu 2003 MCMC methods"
author: "Frederick J. Boehm"
date: "1/19/2020"
output: html_document
---

IN the terminology of @jannink2003estimating, the sequence of updates per iteration is:

1. update QTL inheritance matrix $Q$  
1. update QTL allelic effects $a$  
1. update family means $\beta$ and residual variance $\sigma^2$  
1. update configuration given number of alleles, ie, $C | l$  
1. update the number of alleles $l$

The later @jannink2004optimal uses similar sequence of updates:

1. Update the number of QTL alleles 
1. Update the configuration given the number of alleles
1. update QTL variance (when there are multiple QTL)
1. update allelic effects
1. update position and genotypes jointly
1. update family means



```{r}
get_output <- function(numerator, denominator, current, proposal){
  alpha <- min(1, prod(numerator / denominator))
  bernoulli <- rbinom(n = 1, size = 1, prob = alpha)
  if (bernoulli) {out <- proposal} else {out <- current}
  return(out)
}

update_effects_variance <- function(effects_variance, 
                                    distance = 0.3, 
                                    effects, 
                                    configuration){
  # draw a random proposal from uniform distribution centered at current value
  proposal <- runif(n = 1, 
                    min = max(0, effects_variance - distance), 
                    max = effects_variance + distance
                    )
  # calculate exponents for effects
  exponent <- colSums(configuration)
  # calc numerator
  numerator <- dnorm(effects ^ exponent, 
                     mean = 0, 
                     sd = sqrt(proposal)
                     ) * (1 / min(2 * distance, distance + proposal))
  denominator <- dnorm(effects ^ exponent, 
                       mean = 0, 
                       sd = sqrt(effects_variance)
                       ) * (1 / min(2 * distance, distance + effects_variance))
  output <- get_output(numerator = numerator, 
                       denominator = denominator, 
                       current = effects_variance, 
                       proposal = proposal
                       )
  return(output)
}
# update one effect from the vector of effects
update_effect <- function(effects, 
                          effect_index, # which element of effects is considered for update
                           distance = 0.3, 
                           effects_variance, 
                           trait, 
                           residual_variance, 
                           collapsed_genotypes){
  proposal <- effects
  proposal[effect_index] <- runif(n = 1, 
                    min = effects[effect_index] - distance, 
                    max = effects[effect_index] + distance
                    )
  numerator <- dnorm(trait, 
                     mean = collapsed_genotypes %*% proposal, 
                     sd = sqrt(residual_variance)
                     ) * 
    dnorm(proposal[effect_index], 
          mean = 0, 
          sd = sqrt(effects_variance)
          )
  denominator <- dnorm(trait, 
                     mean = collapsed_genotypes %*% effects, 
                     sd = sqrt(residual_variance)
                     ) * 
    dnorm(effects[effect_index], 
          mean = 0, 
          sd = sqrt(effects_variance)
          )
  output <- get_output(numerator = numerator, 
                       denominator = denominator, 
                       current = effects, 
                       proposal = proposal
                       )
  return(output)
}

update_residual_variance <- function(residual_variance, 
                                     distance = 0.3, 
                                     trait, 
                                     collapsed_genotypes, 
                                     effects){
  proposal <- runif(n = 1, 
                    min = max(0, residual_variance - distance), 
                    max = residual_variance + distance
                    )
  numerator <- dnorm(trait, 
                     mean = collapsed_genotypes %*% effects, 
                     sd = sqrt(proposal)
                     ) * (1 / min(2 * distance, distance + proposal))
  denominator <- dnorm(trait, 
                       mean = collapsed_genotypes %*% effects, 
                       sd = sqrt(residual_variance)
                       ) * (1 / min(2 * distance, distance + residual_variance))
  output <- get_output(numerator = numerator, 
                       denominator = denominator, 
                       current = residual_variance, 
                       proposal = proposal
                       )
  return(output)
}

#' @param configuration an allelic series matrix, ie, binary matrix of 0s and 1s mapping founders to alleles at a single QTL
#' @param genoprobs genotype probabilities matrix for a single marker, ie, n_subjects by n_founders at 1 marker

update_allelic_number <- function(configuration, genoprobs, effects, trait){
  allelic_number <- ncol(configuration)
  founder_number <- nrow(configuration)
  # get proposal
  if ((allelic_number < founder_number) & (allelic_number > 2)){
    increase_indicator <- rbinom(n = 1, size = 1, prob = 0.5)
  }
  if (allelic_number == 2){
    increase_indicator <- 1
  }
  if (allelic_number == founder_number){
    increase_indicator <- 0
  }
  proposal_allelic_number <- allelic_number + increase_indicator - (1 - increase_indicator)
  if (increase_indicator){
    # choose an allele shared by at least two founders
    ## calculate column sums of configuration matrix
    colsums <- colSums(configuration)
    shared_alleles <- which(colsums > 1)
    allele_to_split <- sample(x = shared_alleles, size = 1)
    founders_to_split <- which(configuration[ , allele_to_split] == 1)
    group_indicators <- rbinom(n = length(founders_to_split), size = 1, prob = 0.5)
    # make new configuration matrix
    configuration_proposal <- configuration
    binary <- rep(0, founder_number)
    binary[founders_to_split[as.logical(group_indicators)]] <- 1
    configuration_proposal[ , allele_to_split] <- binary
    ## add a new column
    binary0 <- rep(0, founder_number)
    binary0[founders_to_split[as.logical(1 - group_indicators)]] <- 1
    configuration_proposal <- cbind(configuration_proposal, binary0)
    colnames(configuration_proposal) <- NULL
    new_effect <- rnorm(n = 1, mean = 0, sd = sqrt(effects_variance))
    effects_proposal <- c(effects, new_effect)
    eta_u <- colSums(configuration)[allele_to_split] 
    # how many founders have the allele to 'split'??
    # collapse genoprobs in each of two ways
    collapsed_genotypes <- genoprobs %*% configuration
    collapsed_genotypes_proposal <- genoprobs %*% configuration_proposal
    
    numerator <- 2 * (2 ^ (eta_u - 1) - 1) * 
      sum(colSums(configuration) > 1) * 
      count_configurations(founder_number = founder_number, 
                           allelic_number = allelic_number
                           ) * 
      dnorm(trait, 
            mean = collapsed_genotypes_proposal %*% effects_proposal, 
            sd = sqrt(residual_variance)
            )
    # how many alleles are carried by at least 2 founders?
    denominator <- (allelic_number + 1) * 
      allelic_number * 
      count_configurations(founder_number = founder_number, 
                           allelic_number = 1 + allelic_number
                           ) * 
      dnorm(trait, mean = collapsed_genotypes %*% effects, sd = sqrt(residual_variance))
  } else { # propose a decrease in allelic number
    # choose two alleles to combine into one
    alleles_to_combine <- sample(1:allelic_number, size = 2, replace = FALSE) # vector of length 2
    configuration_proposal <- configuration
    configuration_proposal[ , min(alleles_to_combine)] <- configuration_proposal[ , min(alleles_to_combine)] + configuration_proposal[ , max(alleles_to_combine)]
    configuration_proposal <- configuration_proposal[, - max(alleles_to_combine)]
    effects_proposal <- effects[ - max(alleles_to_combine)]
    # define collapsed genotypes
    collapsed_genotypes_proposal <- genoprobs %*% configuration_proposal
    collapsed_genotypes <- genoprobs %*% configuration
    numerator <- allelic_number * (allelic_number - 1) * count_configurations(founder_number = founder_number, allelic_number = allelic_number) * dnorm(trait, mean = collapsed_genotypes_proposal %*% effects_proposal, sd = sqrt(residual_variance))
    eta_u_plus_v <- colSums(configuration_proposal)[min(alleles_to_combine)]
    l2_proposal <- sum(colSums(configuration_proposal) > 1)
    denominator <- 2 * (2 ^ (eta_u_plus_v - 1) - 1) * 
      l2_proposal * 
      count_configurations(founder_number = founder_number, 
                           allelic_number = allelic_number - 1) * 
      dnorm(trait, mean = collapsed_genotypes %*% effects, sd = sqrt(residual_variance))
  }
  output <- get_output(numerator = numerator, 
             denominator = denominator, 
             current = list(effects, configuration), 
             proposal = list(effects_proposal, configuration_proposal)
             )
  return(output)
} ## need to define inputs, collapsed_geno, collapsed_geno_proposal, etc.##

count_configurations <- function(founder_number = 8, allelic_number){
  # allele labels don't matter, but founder labels matter.
  # we need stirling numbers of the second kind
  return(as.integer(gmp::Stirling2(n = founder_number, k = allelic_number)))
}

update_configuration <- function(configuration, trait, genoprobs, effects){
  # determine which alleles have multiple founders
  alleles_with_multiple_founders <- which(colSums(configuration) > 1)
  # randomly choose an allele with multiple founders
  allele_to_change <- sample(alleles_with_multiple_founders, size = 1)
  # choose a founder with 'allele_to_change' 
  founders_with_allele_to_change <- which(configuration[, allele_to_change] == 1)
  # randomly choose one from 'founders_with_allele_to_change'
  founder_to_change <- sample(founders_with_allele_to_change, size = 1)
  v_possible_alleles <- (1:ncol(configuration))[- allele_to_change]
  v_allele <- sample(v_possible_alleles, size = 1)
  configuration_proposal <- configuration
  configuration_proposal[founder_to_change, allele_to_change] <- 0 
  configuration_proposal[founder_to_change, v_allele] <- 1
  eta_u <- colSums(configuration)[allele_to_change]
  eta_v <- colSums(configuration_proposal)[v_allele]
  l2 <- sum(colSums(configuration) > 1)
  l2_proposal <- sum(colSums(configuration_proposal) > 1)
  collapsed_genotypes <- genoprobs %*% configuration
  collapsed_genotypes_proposal <- genoprobs %*% configuration_proposal
  numerator <- eta_u * l2 * dnorm(trait, 
                                  mean = collapsed_genotypes_proposal %*% effects, 
                                  sd = sqrt(residual_variance)
                                  )
  denominator <- eta_v * l2_proposal * dnorm(trait, 
                                             mean = collapsed_genotypes %*% effects, 
                                             sd = sqrt(residual_variance)
                                             )
  output <- get_output(numerator = numerator, denominator = denominator, current = configuration, proposal = configuration_proposal)
  return(output)
}
```

```{r}
janninkwu_mcmc_one_iteration <- function(configuration, 
                                         genoprobs, 
                                         effects, 
                                         trait, 
                                         residual_variance, 
                                         effects_variance){
  # update allelic number
  out <- update_allelic_number(configuration = configuration, 
                               genoprobs = genoprobs, 
                               effects = effects, 
                               trait = trait
                               )
  effects <- out[[1]] 
  configuration <- out[[2]]
  # update configuration for fixed allelic number
  configuration <- update_configuration(configuration = configuration, 
                                        trait = trait, 
                                        genoprobs = genoprobs, 
                                        effects = effects
                                        )
  effects_variance <- update_effects_variance(effects_variance = effects_variance,
                                              effects = effects,
                                              configuration = configuration
                                              )
  # iterate over effects vector
  for (k in seq_along(effects)){
    effects <- update_effect(effects = effects, 
                              effect_index = k,
                              effects_variance = effects_variance,
                              trait = trait, 
                              residual_variance = residual_variance,
                              collapsed_genotypes = genoprobs %*% configuration
                              )
  }
  ##
  residual_variance <- update_residual_variance(residual_variance = residual_variance, 
                                                trait = trait,
                                                collapsed_genotypes = genoprobs %*% configuration, 
                                                effects = effects
                                                )
  return(list(configuration = configuration, 
              effects = effects, 
              effects_variance = effects_variance, 
              residual_variance = residual_variance)
         )
}
```


## Simulate traits

```{r load_attie}
geno <- readRDS("../data/derived_data/attie_geno.rds")
map <- readRDS("../data/derived_data/attie_map.rds")
```

```{r}
config <- matrix(nrow = 8, ncol = 2)
config[, 1] <- rep(c(0, 1), each = 4)
config[, 2] <- 1 - config[, 1]
tr <- reducedscan::sim1(aprobs = geno$`1`[ , , 100], allelic_series = config, allelic_effects = c(1, 3))
```



## Apply mcmc to infer allelic series at QTL

```{r, mcmc}
gp <- geno$`1`[ , , 100]
config2 <- config
config2[3, 1] <- 1
config2[3, 2] <- 0
# define starting values
effects <- c(1, 3)
configuration <- config2
residual_variance <- 1
effects_variance <- var(c(3, 1))
# define list to hold outputs
output <- list()
for (i in 1:30000){
  output[[i]]<- janninkwu_mcmc_one_iteration(configuration = configuration, 
                                             genoprobs = gp, 
                                             effects = effects, 
                                             trait = tr, 
                                             residual_variance = residual_variance,
                                             effects_variance = effects_variance
                                             )
  configuration <- output[[i]]$configuration
  effects <- output[[i]]$effects
  effects_variance <- output[[i]]$effects_variance
  residual_variance <- output[[i]]$residual_variance
}
```
