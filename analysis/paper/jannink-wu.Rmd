---
title: "Jannink and Wu 2003 MCMC methods"
author: "Frederick J. Boehm"
date: "1/19/2020"
output: html_document
---

IN the terminology of @jannink2003estimating, the sequence of updates per iteration is:

1. update QTL inheritance matrix $Q$  
1. update QTL allelic effects $a$  
1. update family means $\beta$ and residual variance $\sigma^2$  
1. update configuration given number of alleles, ie, $C | l$  
1. update the number of alleles $l$

The later @jannink2004optimal uses similar sequence of updates:

1. Update the number of QTL alleles 
1. Update the configuration given the number of alleles
1. update QTL variance (when there are multiple QTL)
1. update allelic effects
1. update position and genotypes jointly
1. update family means



```{r}
get_output <- function(numerator, denominator, current, proposal){
  alpha <- min(1, prod(numerator / denominator))
  bernoulli <- rbinom(n = 1, size = 1, prob = alpha)
  if (bernoulli) {out <- proposal} else {out <- current}
  return(out)
}

enumerate_configuration <- function(configuration){
  return(apply(X = configuration, MARGIN = 1, FUN = function(x)which(x == 1)))
}
#' Use configuration and effects vector to get each founder's effect, even when there are fewer alleles than founders
expand_effects <- function(effects, enumerated_configuration){
  return(effects[enumerated_configuration])
}


update_effects_variance <- function(effects_variance, 
                                    distance = 0.3, 
                                    effects, 
                                    configuration){
  # draw a random proposal from uniform distribution centered at current value
  proposal <- runif(n = 1, 
                    min = max(0, effects_variance - distance), 
                    max = effects_variance + distance
                    )
  expanded_effects <- expand_effects(effects,
                                     enumerate_configuration(configuration)
                                     )
  # calc numerator
  numerator <- dnorm(expanded_effects, 
                     mean = 0, 
                     sd = sqrt(proposal)
                     ) * (1 / min(2 * distance, distance + proposal))
  denominator <- dnorm(expanded_effects, 
                       mean = 0, 
                       sd = sqrt(effects_variance)
                       ) * (1 / min(2 * distance, distance + effects_variance))
  output <- get_output(numerator = numerator, 
                       denominator = denominator, 
                       current = effects_variance, 
                       proposal = proposal
                       )
  return(output)
}
# update one effect from the vector of effects
update_effect <- function(effects, 
                          effect_index, # which element of effects is considered for update
                           distance = 0.1, 
                           effects_variance, 
                           trait, 
                           residual_variance, 
                           collapsed_genotypes){
  proposal <- effects
  proposal[effect_index] <- runif(n = 1, 
                    min = effects[effect_index] - distance, 
                    max = effects[effect_index] + distance
                    )
  numerator <- dnorm(trait, 
                     mean = collapsed_genotypes %*% proposal, 
                     sd = sqrt(residual_variance)
                     ) * 
    dnorm(proposal[effect_index], 
          mean = 0, 
          sd = sqrt(effects_variance)
          )
  denominator <- dnorm(trait, 
                     mean = collapsed_genotypes %*% effects, 
                     sd = sqrt(residual_variance)
                     ) * 
    dnorm(effects[effect_index], 
          mean = 0, 
          sd = sqrt(effects_variance)
          )
  output <- get_output(numerator = numerator, 
                       denominator = denominator, 
                       current = effects, 
                       proposal = proposal
                       )
  return(output)
}

update_residual_variance <- function(residual_variance, 
                                     distance = 0.3, 
                                     trait, 
                                     collapsed_genotypes, 
                                     effects){
  proposal <- runif(n = 1, 
                    min = max(0, residual_variance - distance), 
                    max = residual_variance + distance
                    )
  numerator <- dnorm(trait, 
                     mean = collapsed_genotypes %*% effects, 
                     sd = sqrt(proposal)
                     ) * (1 / min(2 * distance, distance + proposal))
  denominator <- dnorm(trait, 
                       mean = collapsed_genotypes %*% effects, 
                       sd = sqrt(residual_variance)
                       ) * (1 / min(2 * distance, distance + residual_variance))
  output <- get_output(numerator = numerator, 
                       denominator = denominator, 
                       current = residual_variance, 
                       proposal = proposal
                       )
  return(output)
}

#' @param configuration an allelic series matrix, ie, binary matrix of 0s and 1s mapping founders to alleles at a single QTL
#' @param genoprobs genotype probabilities matrix for a single marker, ie, n_subjects by n_founders at 1 marker

update_allelic_number <- function(configuration, genoprobs, effects, trait){
  allelic_number <- ncol(configuration)
  founder_number <- nrow(configuration)
  # get proposal
  if ((allelic_number < founder_number) & (allelic_number > 2)){
    increase_indicator <- rbinom(n = 1, size = 1, prob = 0.5)
  }
  if (allelic_number == 2){
    increase_indicator <- 1
  }
  if (allelic_number == founder_number){
    increase_indicator <- 0
  }
  if (increase_indicator){
    cp_out <- calc_prob_allelic_number_increase(configuration,
                                              genoprobs, 
                                              effects, 
                                              effects_variance, 
                                              trait, 
                                              residual_variance
                                              )
  } else { # propose a decrease in allelic number
    cp_out <- calc_prob_allelic_number_decrease(configuration, 
                                                genoprobs, 
                                                effects, 
                                                trait, 
                                                residual_variance
                                                )
  }
  output <- get_output(numerator = cp_out$numerator, 
             denominator = cp_out$denominator, 
             current = list(effects, configuration), 
             proposal = list(cp_out$effects_proposal, cp_out$configuration_proposal)
             )
  return(output)
} ## need to define inputs, collapsed_geno, collapsed_geno_proposal, etc.##
##
calc_prob_allelic_number_decrease <- function(configuration, 
                                              genoprobs, 
                                              effects, 
                                              trait, 
                                              residual_variance){
# propose a decrease in allelic number
  allelic_number <- ncol(configuration)
  founder_number <- nrow(configuration)
    # choose two alleles to combine into one
  alleles_to_combine <- sample(1:allelic_number, size = 2, replace = FALSE) # vector of length 2
  # make configuration proposal matrix
  configuration_proposal <- calc_configuration_combining_alleles(configuration, alleles_to_combine)
  # make effects proposal vector
  effects_proposal <- effects[ - max(alleles_to_combine)]
  # define collapsed genotypes
  collapsed_genotypes_proposal <- genoprobs %*% configuration_proposal
  collapsed_genotypes <- genoprobs %*% configuration
  numerator <- allelic_number * 
    (allelic_number - 1) * 
    count_configurations(founder_number = founder_number, 
                         allelic_number = allelic_number
                         ) * 
    dnorm(trait, 
          mean = collapsed_genotypes_proposal %*% effects_proposal, 
          sd = sqrt(residual_variance)
          )
  # define etau plus etav
  eta_u_plus_v <- colSums(configuration_proposal)[min(alleles_to_combine)]
  l2_proposal <- sum(colSums(configuration_proposal) > 1)
  denominator <- 2 * (2 ^ (eta_u_plus_v - 1) - 1) * 
    l2_proposal * 
    count_configurations(founder_number = founder_number, 
                         allelic_number = allelic_number - 1
                         ) * 
    dnorm(trait, 
          mean = collapsed_genotypes %*% effects, 
          sd = sqrt(residual_variance)
          )
  return(list(numerator = numerator, 
              denominator = denominator,
              configuration_proposal = configuration_proposal, 
              effects_proposal = effects_proposal
              )
         )
}
##
calc_configuration_combining_alleles <- function(configuration, 
                                                 alleles_to_combine){
  configuration[ , min(alleles_to_combine)] <- configuration[ , min(alleles_to_combine)] +
    configuration[ , max(alleles_to_combine)]
  out <- configuration[, - max(alleles_to_combine)]
  return(out)
}
##
calc_prob_allelic_number_increase <- function(configuration,
                                              genoprobs, 
                                              effects, 
                                              effects_variance, 
                                              trait, 
                                              residual_variance){
    # choose an allele shared by at least two founders
    ## calculate column sums of configuration matrix
    colsums <- colSums(configuration)
    shared_alleles <- which(colsums > 1)
    allele_to_split <- sample(x = shared_alleles, size = 1)
    founders_to_split <- which(configuration[ , allele_to_split] == 1)
    group_indicators <- rbinom(n = length(founders_to_split), size = 1, prob = 0.5)
    # make new configuration matrix
    configuration_proposal <- configuration
    founder_number <- nrow(configuration)
    allelic_number <- ncol(configuration)
    binary <- rep(0, founder_number)
    binary[founders_to_split[as.logical(group_indicators)]] <- 1
    configuration_proposal[ , allele_to_split] <- binary
    ## add a new column
    binary0 <- rep(0, founder_number)
    binary0[founders_to_split[as.logical(1 - group_indicators)]] <- 1
    configuration_proposal <- cbind(configuration_proposal, binary0)
    colnames(configuration_proposal) <- NULL
    new_effect <- rnorm(n = 1, 
                        mean = 0, 
                        sd = sqrt(effects_variance)
                        ) # check this!!
    effects_proposal <- c(effects, new_effect)
    eta_u <- colSums(configuration)[allele_to_split] 
    # how many founders have the allele to 'split'??
    # collapse genoprobs in each of two ways
    collapsed_genotypes <- genoprobs %*% configuration
    collapsed_genotypes_proposal <- genoprobs %*% configuration_proposal
    
    numerator <- 2 * (2 ^ (eta_u - 1) - 1) * 
      sum(colSums(configuration) > 1) * 
      count_configurations(founder_number = founder_number, 
                           allelic_number = allelic_number
                           ) * 
      dnorm(trait, 
            mean = collapsed_genotypes_proposal %*% effects_proposal, 
            sd = sqrt(residual_variance)
            )
    # how many alleles are carried by at least 2 founders?
    denominator <- (allelic_number + 1) * 
      allelic_number * 
      count_configurations(founder_number = founder_number, 
                           allelic_number = 1 + allelic_number
                           ) * 
      dnorm(trait, 
            mean = collapsed_genotypes %*% effects, 
            sd = sqrt(residual_variance)
            )
  return(list(numerator = numerator, 
              denominator = denominator,
              configuration_proposal = configuration_proposal, 
              effects_proposal = effects_proposal
              )
         )
}


count_configurations <- function(founder_number = 8, allelic_number){
  # allele labels don't matter, but founder labels matter.
  # we need stirling numbers of the second kind
  return(as.integer(gmp::Stirling2(n = founder_number, k = allelic_number)))
}

update_configuration <- function(configuration, trait, genoprobs, effects){
  # determine which alleles have multiple founders
  alleles_with_multiple_founders <- which(colSums(configuration) > 1)
  # randomly choose an allele with multiple founders
  allele_to_change <- sample(alleles_with_multiple_founders, size = 1)
  # choose a founder with 'allele_to_change' 
  founders_with_allele_to_change <- which(configuration[, allele_to_change] == 1)
  # randomly choose one from 'founders_with_allele_to_change'
  founder_to_change <- sample(founders_with_allele_to_change, size = 1)
  v_possible_alleles <- (1:ncol(configuration))[- allele_to_change]
  v_allele <- sample(v_possible_alleles, size = 1)
  configuration_proposal <- configuration
  configuration_proposal[founder_to_change, allele_to_change] <- 0 
  configuration_proposal[founder_to_change, v_allele] <- 1
  eta_u <- colSums(configuration)[allele_to_change]
  eta_v <- colSums(configuration_proposal)[v_allele]
  l2 <- sum(colSums(configuration) > 1)
  l2_proposal <- sum(colSums(configuration_proposal) > 1)
  collapsed_genotypes <- genoprobs %*% configuration
  collapsed_genotypes_proposal <- genoprobs %*% configuration_proposal
  numerator <- eta_u * l2 * dnorm(trait, 
                                  mean = collapsed_genotypes_proposal %*% effects, 
                                  sd = sqrt(residual_variance)
                                  )
  denominator <- eta_v * l2_proposal * dnorm(trait, 
                                             mean = collapsed_genotypes %*% effects, 
                                             sd = sqrt(residual_variance)
                                             )
  output <- get_output(numerator = numerator, denominator = denominator, current = configuration, proposal = configuration_proposal)
  return(output)
}
```

```{r}
janninkwu_mcmc_one_iteration <- function(configuration, 
                                         genoprobs, 
                                         effects, 
                                         trait, 
                                         residual_variance, 
                                         effects_variance){
  # update allelic number
  out <- update_allelic_number(configuration = configuration, 
                               genoprobs = genoprobs, 
                               effects = effects, 
                               trait = trait
                               )
  effects <- out[[1]] 
  configuration <- out[[2]]
  # update configuration for fixed allelic number
  configuration <- update_configuration(configuration = configuration, 
                                        trait = trait, 
                                        genoprobs = genoprobs, 
                                        effects = effects
                                        )
  effects_variance <- update_effects_variance(effects_variance = effects_variance,
                                              effects = effects,
                                              configuration = configuration
                                              )
  # iterate over effects vector
  for (k in seq_along(effects)){
    effects <- update_effect(effects = effects, 
                              effect_index = k,
                              effects_variance = effects_variance,
                              trait = trait, 
                              residual_variance = residual_variance,
                              collapsed_genotypes = genoprobs %*% configuration
                              )
  }
  ##
  residual_variance <- update_residual_variance(residual_variance = residual_variance, 
                                                trait = trait,
                                                collapsed_genotypes = genoprobs %*% configuration, 
                                                effects = effects
                                                )
  return(list(configuration = configuration, 
              effects = effects, 
              effects_variance = effects_variance, 
              residual_variance = residual_variance)
         )
}
```


## Simulate traits

```{r load_attie}
geno <- readRDS("../data/derived_data/attie_geno.rds")
map <- readRDS("../data/derived_data/attie_map.rds")
```

```{r}
config <- matrix(nrow = 8, ncol = 2)
config[, 1] <- rep(c(0, 1), each = 4)
config[, 2] <- 1 - config[, 1]
tr <- reducedscan::sim1(aprobs = geno$`1`[ , , 100], allelic_series = config, allelic_effects = c(1, 3))
```



## Apply mcmc to infer allelic series at QTL

```{r, mcmc}
gp <- geno$`1`[ , , 100]
config2 <- config
config2[3, 1] <- 1
config2[3, 2] <- 0
# define starting values
effects <- c(1, 3)
configuration <- config2
residual_variance <- 1
effects_variance <- 1
# define list to hold outputs
output <- list()
for (i in 1:1000){
  output[[i]]<- janninkwu_mcmc_one_iteration(configuration = configuration, 
                                             genoprobs = gp, 
                                             effects = effects, 
                                             trait = tr, 
                                             residual_variance = residual_variance,
                                             effects_variance = effects_variance
                                             )
  configuration <- output[[i]]$configuration
  effects <- output[[i]]$effects
  effects_variance <- output[[i]]$effects_variance
  residual_variance <- output[[i]]$residual_variance
}
```
